\documentclass[12pt, a4paper, twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage[cm]{fullpage}
\usepackage{fancyhdr}
\usepackage{textcomp}
\usepackage{graphicx}

\begin{document}

\title{Relatório do Experimento 1 de OAC}
\author{
Arthur S. Couto: 16/0002575 \\
Cristiano Silva Júnior: 13/0070629 \\
Cristiano Silva Júnior: 13/0070629 \\
Cristiano Silva Júnior: 13/0070629}
\date{5 de Maio de 2017}
\maketitle

\section{Exercício 1}

\subsection{Exercício 1.1}

Lendo o programa \textit{sort.s} dado, nota-se que ele vai realizar um  ordenamento decrescente devido à única comparação presente no código estar  invertida. Após inverter os registradores para realizar a comparação correta, podemos analisar o programa usando a ferramenta \textit{Instruction Counter} do \textit{Mars}, contamos 551 instruções, sendo 204 do tipo R, 294 do tipo I e 53 do tipo J para o vetor dado. Utilizando a ferramenta de estatísticas \textit{Instructions statistics}, foram 31\% de instruções de ULA; 13\% do tipo \textit{jump}; 13\% do tipo\textit{branch}; 27\% de memória; e 16\% de outros tipos.

\subsection{Exercício 1.2}

Reutilizando o programa \textit{sort.s}, podemos analisar este algoritmo de ordenamento para outras entradas. Considerando as entradas $v_o(n) = {1,2,3,...,n}$ e $v_i(n)={n,n-1,n-2,...,1}$ para $n={1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100}$, podemos calcular o número de instruções para cada $n$ e calcular o tempo de execução $t$ com os valores sugeridos de frequência de clock e de CPI. A relação $n \cdot t$ nas figuras 1 e 2.

% TODO Calcular n x t
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{ex1/best.png}
    \caption{Melhores casos de ordenamento}
\end{figure}


\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{ex1/worst.png}
    \caption{Piores casos de ordenamento}
\end{figure}

Nota-se que o ordenamento de um vetor ordenado é simplesmente checar se o vetor já está ordenado, logo se espera que esta operação tenha complexidade $O(n)$; enquanto que a mesma operação em um vetor inversamente ordenado é pior caso da operação de ordenação. Como está sendo usado o algoritmo Bubble Sort, a complexidade deste ordenamento é $O(n^2)$. Estas complexidades ficam evidentes nos gráficos gerados.

\section{Exercício 2}

\subsection{Exercício 2.1}

O programa \textit{sortc.s} foi comentado para identificar o que cada uma das diretivas faz baseado nas especificações do GCC.

\subsection{Exercício 2.2}

Para identificar quais diretivas poderiam ser utilizadas pelo MARS, comparou-se quais as diretivas aceitas pelo MARS que eram geradas pelo GCC. Aquelas diretivas que não eram comuns a ambos programas foram removidas. A saber, somente as seguintes diretivas são aceitas pelo MARS e pelo GCC:

\begin{itemize}
    \item \textit{.globl}
    \item \textit{.align}
    \item \textit{.word}
    \item \textit{.ascii}
    \item \textit{.data}
    \item \textit{.text}
    \item \textit{.set}
\end{itemize}

Todas as outras foram removidas. Aparentemente, o MARS é capaz de ignorar algumas diretivas que não fazem parte da sua especificação, como .ident e .end. Além disso, o GCC compreende que algumas instruções são realizadas de forma diferente pelo MARS. Foram elas:

\begin{itemize}
    \item o GCC produzia sempre dois pares de instruções \textit{lui} e \textit{addiu} chamando \textit{labels} em seus argumentos, o que é inválido para o MARS. Neste caso, substituiu-se esse par de instruções pelas pseudo-instrução \textit{la \$rr, label} onde \textit{\$rr} é o registrador desejado e \textit{label} é um label qualquer. Neste sentido, também foi necessário substituir todas as ocorrências de \textit{j label} para \textit{jr label}, já que o MARS não aceita um \textit{label} como argumento para a instrução \textit{jump}.
    \item Dever-se-á substituir as chamadas de funções da \textit{stdio.h} do GCC por operações equivalentes em MIPS dependendo da necessidade do programa. Funções como \textit{printf} e \textit{scanf} fazem operações bastante complexas com strings, que são muito complicadas de serem implementadas em Assembly à princípio.
\end{itemize}

\subsection{Exercício 2.3}

% TODO Fazer com que os programas convertidos do C rodem no MARS
% TODO Contar as instruções

\begin{itemize}
    \item Sem otimizações: 1840 instruções
\end{itemize}

\section{Exercício 3}

\subsection{Exercício 3.0}
Todos os comandos implementados na biblioteca gráfica para a coloração de um pixel consistem em carregar o valor da cor desejada na posição equivalente na memória. A relação entre o par de coordenadas x e y dos pixels no display do MARS e sua respectiva posição M no memory map se dá por meio da relação aritmética simples:

$$M = 0xff000000 + x + 320y $$
 
\subsection{Exercício 3.1}

O desenho das linhas entre dois pixels, implementado no procedimento \textit{LINEPROC}, tem como base o cálculo de uma equação de reta que conecte o centro dos dois pontos. Os elementos nessa reta são definidos e manipulados em ponto flutuante, o que aumenta significativamente a sua resolução e permite uma melhor aproximação de retas no espaço euclidiano.

A partir dessa reta abstrata e de um terceiro argumento, definido como espessura ou tolerância, colore-se o traço real da linha no Bitmap Display. A distância de um pixel até a reta é definida pela distância vetorial entre as coordenadas cartesianas do centro do pixel e a própria. Se esse valor for menor que a margem ou tolerância estabelecida, o pixel pertence ao traçado da linha. Esse método permite desenhar linhas de forma versátil e precisa, criando traços sempre conexos e de espessura arbitrária.

\subsection{Exercício 3.2}

Baseado no procedimento de traçado de linhas, a construção de polígonos torna-se apenas um encadeamento de chamadas a essas subrotinas. A rotina \textit{POLY} implementa esse processo por meio do empilhamento dos pontos consecutivos que comporiam o polígono. 

A subrotina \textit{LINEPROC} é então chamada repetidamente, percorrendo a pilha de tal forma que o ponto de chegada da linha anterior se torna o ponto de saída da próxima - até a última linha, que conecta o primeiro ponto ao último.

\subsection{Exercício 3.3}

A elipse é implementada de forma semelhante à linha na subrotina \textit{ELIPSEPROC}. Parametriza-se uma equação de elipse focada nos dois pixels fornecidos e calcula-se a distância de cada ponto a esse objeto geométrico. Esse valor determina se o pixel em questão pertence ou não ao traço da elipse.

\subsection{Exercício 3.4}

O preenchimento, por sua vez, é realizado em \textit{DROPBUCKET}. 

\subsection{Exercício 3.5}
O traçar do quadrado se torna uma aplicação simples da rotina \textit{POLY}. A partir do centro e do lado, os quatro pontos podem ser obtidos por meio de translações de metade do lado nos dois eixos. Esses pontos são subsequentemente inseridos na função de desenho de polígonos.

\subsection{Exercício 3.6}
O círculo é, naturalmente, apenas uma elipse em que os dois focos coincidem. A realização desse procedimento consiste apenas na chamada da função elipse

\subsection{Exercício 3.7}
O desenho do triângulo equilátero deriva de uma identidade simples:

$$||O-V|| = \frac{\sqrt{3}}{3}l $$

Onde $||O-V||$ é o módulo da distância do centro até um dos vértices e $l$ é o lado. Dessa forma, dado o centro é possível encontrar o vértice superior do triângulo: soma-se essa distância a sua coordenada y. 

A partir do vértive superior, encontrar os outros dois que comporão o polígono consiste em translações simples determinadas pelo lado do triângulo e o seno dos ângulos internos ($60^o$)

\subsection{Exercício 3.8}

Com acesso a todas essas ferramentas, a construção das bandeiras é possível via aplicação iterada dos procedimentos da livraria.

Assim, foram feitas as bandeiras dos Estados Unidos, Brasil, Japão, Israel e Butão.


\end{document}
